import { TechnologyContent } from '@/app/lib/contentTypes'

export const technologyContent: TechnologyContent = {
    title: "वर्तमान AI कोडिंग टूल्स के साथ समस्या",
    problem: {
        title: "वे कोड जेनरेट करते हैं, लेकिन सिस्टम को नहीं समझते",
        subtitle: "आज के AI कोडिंग सहायकों ने प्रभावशाली परिणाम हासिल किए हैं—कोड को ऑटो-कंप्लीट करना, फ़ंक्शंस जेनरेट करना, भाषाओं के बीच अनुवाद करना। लेकिन वे सभी एक मौलिक सीमा साझा करते हैं: वे सॉफ़्टवेयर को जेनरेट करने के लिए टेक्स्ट के रूप में मानते हैं, न कि समझने के लिए सिस्टम के रूप में।",
        body: "सॉफ़्टवेयर इंजीनियरिंग एक टेक्स्ट जेनरेशन समस्या नहीं है। यह एक सिस्टम रीज़निंग समस्या है।",
        limitations: [
            {
                title: "संदर्भ समस्या",
                description: "कोडबेस में हजारों फ़ाइलों में लाखों लाइनें होती हैं। वर्तमान टूल सरल रिट्रीवल के माध्यम से इसे पाटने का प्रयास करते हैं, लेकिन सॉफ़्टवेयर में प्रासंगिकता टेक्स्चुअल समानता नहीं है—यह कारणात्मक संबंधों, निर्भरता श्रृंखलाओं और आर्किटेक्चरल सीमाओं के बारे में है।"
            },
            {
                title: "तर्क अंतर",
                description: "सिंटैक्टिकली सही कोड जेनरेट करने और स्वस्थ इंजीनियरिंग निर्णय लेने के बीच एक मौलिक अंतर है। जब अनुभवी इंजीनियर कोड को संशोधित करते हैं, तो वे सिस्टम-वाइड आर्किटेक्चरल प्रभावों, निर्भरता प्रभावों, प्रदर्शन व्यापार-बंदों और रखरखाव योग्यता पर विचार करते हैं।"
            },
            {
                title: "सत्यापन अंतर",
                description: "सॉफ़्टवेयर इंजीनियरिंग को सटीकता की आवश्यकता होती है, न कि प्रशंसनीयता की। वर्तमान टूल में सिंटैक्स जाँच से परे मान्य करने के लिए तंत्र की कमी है। वे यह तर्क नहीं कर सकते कि क्या परिवर्तन सिस्टम इनवेरिएंट्स को बनाए रखते हैं, आर्किटेक्चरल सीमाओं का सम्मान करते हैं, या सुरक्षा कमजोरियों को पेश करते हैं।"
            }
        ]
    },
    approach: {
        title: "सॉफ़्टवेयर इंजीनियरिंग के लिए निर्मित",
        subtitle: "हमने एक अलग प्रश्न से शुरुआत की: \"AI बेहतर कोड कैसे लिख सकता है?\" नहीं बल्कि \"AI सॉफ़्टवेयर सिस्टम को उसी तरह कैसे समझ सकता है जैसे अनुभवी इंजीनियर करते हैं?\"",
        sections: [
            {
                title: "सामान्यीकरण पर विशेषज्ञता",
                body: "सॉफ़्टवेयर इंजीनियरिंग के विभिन्न पहलुओं को मौलिक रूप से विभिन्न प्रकार के तर्क की आवश्यकता होती है। सब कुछ को एक ही मॉडल में संकुचित करने के बजाय, हम विशेषीकृत AI घटकों का उपयोग करते हैं—प्रत्येक सॉफ़्टवेयर तर्क के विशिष्ट डोमेन के लिए डिज़ाइन किया गया है—एक इंजीनियरिंग टीम की तरह मिलकर काम करते हुए।"
            },
            {
                title: "सहयोगी तर्क",
                body: "सॉफ़्टवेयर निर्णयों को अक्सर प्रतिस्पर्धी चिंताओं के बीच व्यापार-बंदों का वजन करने की आवश्यकता होती है। हमारी आर्किटेक्चर विशेषीकृत घटकों को संदर्भ साझा करने, धारणाओं को चुनौती देने और संरचित समन्वय के माध्यम से सहमति की ओर काम करने में सक्षम बनाती है।"
            },
            {
                title: "सिस्टम-वाइड समझ",
                body: "सॉफ़्टवेयर समझ कई स्तरों पर काम करती है: सिंटैक्स, सिमेंटिक्स, आर्किटेक्चरल पैटर्न, डिज़ाइन इरादे और सिस्टम-वाइड गुण। हम लेयर्ड रीज़निंग का उपयोग करते हैं जहाँ विभिन्न घटक अमूर्तता के विभिन्न स्तरों पर काम करते हैं।"
            },
            {
                title: "पुनर्प्राप्ति से परे संदर्भ",
                body: "डिस्कनेक्टेड कोड स्निपेट्स को खींचने के बजाय, हम सिस्टम संबंधों के गतिशील प्रतिनिधित्व बनाने के लिए दृष्टिकोण विकसित कर रहे हैं—न केवल कोड को कैप्चर करते हुए, बल्कि निर्भरताओं, इनवेरिएंट्स और आर्किटेक्चरल सीमाओं के वेब को भी।"
            }
        ]
    },
    difference: {
        title: "अंतर",
        comparison: [
            {
                label: "वर्तमान टूल",
                value: "कोड जेनरेट करें → सिंटैक्स के लिए अनुकूलित करें → संदर्भ सीमाओं के भीतर काम करें → सामान्य-उद्देश्य आर्किटेक्चर"
            },
            {
                label: "हमारा दृष्टिकोण",
                value: "सिस्टम समझें → आर्किटेक्चर के बारे में तर्क दें → गतिशील प्रतिनिधित्व बनाएं → सॉफ़्टवेयर इंजीनियरिंग के लिए उद्देश्य-निर्मित"
            }
        ]
    }
}
